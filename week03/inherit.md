## 상속은 뭘까? 🤔

상속은 "확장"한다는 개념이다. 따라서 부모 클래스의 <code>public, protected</code>로 선언된 모든 변수와 메소드를 내가 가지고 있는 것 처럼 사용할 수 있다. 반대로 <code>package-private(default), private</code>로 선언된 변수나 메소드들은 자식 클래스에서 사용할 수 없다.

## UML

UML(Unified Modeling Language)은 개발을 하기 전에 어떤 프로그램을 만들지에 대한 분석과 설계 작업을 의미한다. Class Diagram, Sequence Diagram, Use Case Diagram 등 여러 다이어그램을 통해 개발될 프로그램이 어떻게 구성되고 작동되어야 하는지 표현한다.

책에서는 Class Diagram 만을 언급했는데, Class Diagram의 경우 화살표로 상속 관계를 표현한다. (자식 → 부모) 상속 관계가 아닌 참조 관계는 일반적인 직선으로 표현한다.

## 부모 생성자 호출?

상속에서 특별한 점은 부모의 생성자를 호출한다는 점이다. 쉽게 말하자면, 상속을 받은 클래스가 생성자를 호출할 경우에는 자동으로 부모 클래스의 기본 생성자가 호출된다는 것이다. (자바에서는 다중 상속이 불가능하다.)

그렇다면, 부모 클래스에 매개 변수가 존재하는 생성자를 만들어주면 어떻게 될까? 당연히 에러가 발생한다. 매개 변수가 있는 생성자를 만들었을 경우에는 기본 생성자는 자동으로 만들어지지 않기 때문에, 자식 클래스에서 부모 클래스의 기본 생성자 찾지 못하기 때문이다.

이 문제를 해결하는 방법은 2가지가 있다.

- 부모 클래스에 매개 변수가 없는 기본 생성자를 만들어준다.
- 자식 클래스에서 부모 클래스의 생성자를 명시적으로 지정하는 <code>super()</code>를 이용한다.

## super()

위에서 언급했듯, <code>super()</code> 키워드는 부모 클래스의 생성자를 호출한다는 것을 의미한다. 기억해야할 점은, 이 키워드는 자식 클래스의 생성자에 지정하지 않아도 자식 클래스를 컴파일하라 때 자동으로 들어간다는 것이다.

만약 참조 자료형을 매개 변수로 받는 생성자가 여러개가 있고, <code>super()</code> 키워드에 null을 넘겨주면 어떻게 될까? 이 경우, 부모 클래스로의 참조가 모호하다는 에러가 발생한다. 즉, null을 넘겨주게 되면 어떤 클래스를 찾아가야 하는지를 자바 컴파일러에서 마음대로 정할 수 없기 때문에, 모호하게 null을 넘기는 것보다 호출하고자 하는 생성자의 기본 타입을 넘겨주어야 한다는 것이다.

다시 정리해보자면, 자바는 부모의 매개 변수가 없는 기본 생성자를 찾는 것이 기본이다. 따라서 부모 클래스에 매개 변수가 있는 생성자만 있을 경우에는 <code>super()</code> 키워드를 이용하여 부모 생성자를 반드시 호출해야 한다. <code>super()</code> 키워드는 자식 클래스 생성자에서 가장 첫 줄에 선언되어야 하며, 명시적으로 지정하지 않을 경우 컴파일시 자동으로 <code>super()</code> 키워드가 추가된다.

## Overriding

> 오버라이딩은 사전적으로 "최우선시 되는"이라는 의미를 가지고 있다.
 
책에서도 그렇지만, 면접에서도 가장 많이 등장하는 키워드다. 우선, 부모 클래스에 선언되어 있는 메소드와 동일한 메소드를 자식 클래스에서도 선언해서 사용할 수 있다. 자식 클래스에서 부모 클래스에 있는 메소드와 동일하게 선언하는 것을 메소드 오버라이딩이라고 한다.

접근 제어자, 리턴 타입, 메소드 이름, 매개 변수 타입 및 개수가 모두 동일해야한다는 조건이 만족해야 메소드 오버라이딩이라는 개념을 적용할 수 있다. (이러한 조건을 "동일한 시그니처를 가진다"라고도 한다.)

## 접근 제어자가 다른 Overriding?

오버라이딩은 접근 제어자가 더 확대 되는 것은 문제가 되지 않지만, 축소되는 것은 문제가 된다.

```
public > protected > package-private(default) > private
```

부모 클래스에서 <code>public</code>으로 선언한 것을 자식이 <code>private</code>로 선언하면 안된다. 반대로 부모 클래스에서 <code>private</code>로 선언했다면 자식 클래스는 어떤 것으로 선언해도 무관하다.

```java
public class ParentClass {
    private void overrideMethod() {}
}
```

```java
public class ChildClass {
    public void overrideMethod() {}
}
```

## 상속 관계에서의 형 변환이라고? 참조 자료형도 형 변환이 가능하다고?!

상속 관계에서는 객체를 생성할 때 특이한 점을 가지고 있다. 자바 컴파일러에서는 자식 객체를 생성할 때 부모 생성자를 사용하면 안된다고 한다. 따라서 명시적으로 형 변환을 해줘야한다고 한다.

자식 클래스의 타입을 부모 클래스 타입으로 형 변환하면 부모 클래스에서 호출할 수 있는 메소드들은 자식 클래스에서도 호출이 가능하기에 문제가 안된다. 이 경우에는 형 변환을 명시적으로 해줄 필요는 없다. 반대로 부모 클래스에서 자식 클래스로 형 변환은 이루어질 수 없다.

생각을 해보면 <code>int</code>와 <code>long</code>의 형 변환처럼 굉장히 단순한 개념이다. 우리는 상속이라는 개념을 "확장"에 비유를 했다. 즉, 부모의 것을 가지고 있는 자식 클래스는 <code>long</code> 타입으로, 자식의 것을 가지고 있지 않은 부모 클래스를 <code>int</code>로 비유할 수 있다.

즉, 앞에서 공부한 것 처럼 <code>int</code>는 <code>long</code>으로의 확장이 손쉽게 가능하지만, 그 반대는 명시적으로 선언해주어야 하는 것과 동일한 개념이다.

그렇다면 어떻게 형 변환을 할까? 책에 있는 코드를 살펴보면 다음과 같다.

하단의 예시의 경우에는 실패를 하게 된다. 그 이유는 parent1 객체는 Parent 클래스로 만들었기 때문에 캐스팅이 안된다는 오류가 발생한다.

```java
Parent parent1 = new Parent();
Child child1 = new Child();

Parent parent2 = child1;
Child child2 = (Child)parent1;
```

반대로, 하단의 코드에서는 parent 객체로 만들었지만 실제로는 Child 객체이기 때문에 형 변환 과정에서 문제가 발생하지 않는다.

```java
Child child = new Child();
Parent parent = child;
Child child2 = (Child)parent;
```

결론은 일반적으로 여러 개의 값을 처리하거나 매개 변수로 값을 전달할 때는 보통 부모 클래스의 타입으로 보낸다는 것이다. 배열과 같이 여러 값을 한번에 보낼 때 각 타입별로 구분해서 메소드를 만들어야 하는 문제가 발생할 수 있기 때문이다.

## instanceof

<code>instanceof</code> 예약어는 객체가 어떤 객체인지 타입을 점검할 때 사용한다. 단, 타입을 점검할 때는 가장 하위에 있는 자식 타입부터 확인을 해야 제대로 타입 점검이 가능하다는 점을 주의해야한다.

## 다형성

다형성(Polymorphism)도 면접 질문에 많이 나오는 개념이다. 다형성은 형태가 다양하다는 의미를 가지고 있는데, 이는 형 변환을 하더라도 실제 호출되는 것은 원래 객체에 있는 메소드가 호출된다는 개념이다.

---

## 질문에 답해보자 💁‍♂️

**Q1. 상속을 받는 클래스의 선언문에 사용하는 키워드는 무엇인가요?**

```java
extends
```

**Q2. 상속을 받은 클래스의 생성자를 수행하면 부모의 생성자도 자동으로 수행되나요?**

네

**Q3. 부모 클래스의 생성자를 자식 클래스에서 직접 선택하려고 할 때 사용하는 예약어는 무엇인가요?**

```java
super();
```

**Q4 메소드 Overriding과 Overloading을 정확하게 설명해 보세요.**

쉽게 말한다면 오버라이딩은 덮는다는 개념이라면 오버로딩은 확장의 개념이다.

오버라이딩은 상위 클래스의 메서드를 하위 클래스가 재정의 하는 것이고 메소드의 이름과 매개 변수의 개수, 타입이 동일해야하며 상위 클래스의 동작을 상속받은 하위 클래스에서 변경하기 위해 사용된다.

오버로딩은 메소드 이름은 같고 매개 변수의 개수나 타입이 다른 함수를 의미한다.

결국, 오버로딩은 기존에 없던 새로운 메소드를 정의하는 것이라면 오버라이딩은 상속받은 메소드의 내용만 변경하는 것이다.

**Q5. A가 부모, B가 자식 클래스라면, A a=new B(); 형태로 객체 생성이 가능한가요?**

네

**Q6. 명시적으로 형 변환을 하기 전에 타입을 확인하려면 어떤 예약어를 사용해야 하나요?**

```java
instanceof
```

**Q7. 6에서 사용한 예약어의 좌측에는 어떤 값이, 우측에는 어떤 값이 들어가나요?**

앞에는 객체, 뒤에는 클래스 타입

**Q8. 6의 예약어의 수행 결과는 어떤 타입으로 제공되나요?**

boolean

**Q9. Polymorphism이라는 것은 도대체 뭔가요?**

다형성은 하나의 객체에 여러 가지 타입을 대입할 수 있는 것을 의미한다. 반대로 단형성은 하나의 객체에 하나의 타입만 대응할 수 있다.

다형성을 활용하면 기능을 확장하거나, 객체를 변경해야할 때 타입 변경 없이 객체 주입만으로 수정이 일어나게 할 수 있다. 또한 상속을 사용한다면 중복되는 코드까지 제거할 수 있다. (대표적으로 오버로딩에 해당하는 개념이다.)